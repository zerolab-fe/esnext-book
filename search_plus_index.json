{"./":{"url":"./","title":"简介","keywords":"","body":" ECMAScript Next 系列教程 📘 说明 ECMAScript Next 系列教程，是对 ECMAScript 2016、2017、2018、2019、2020、2021 等新特性的整理笔记。本教程系列将跟随 ECMAScript 官方已经完成的提案同步更新。 📖 目录 ECMAScript 2016 (ES7) ECMAScript 2017 (ES8) ECMAScript 2018 (ES9) ECMAScript 2019 (ES10) ECMAScript 2020 (ES11) ECMAScript 2021 (ES12) WIP 👨‍💻 作者 木子朗 📄 参考 Finished ProposalsJavaScript 参考 - JavaScript | MDNECMAScript 6 入门 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2021/es2021.html":{"url":"es2021/es2021.html","title":"ECMAScript 2021 (ES12)","keywords":"","body":"ECMAScript 2021 (ES12) 目录 String.prototype.replaceAll Promise.any WeakRefs Logical Assignment Operators Numeric Separators Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2021/string-replaceall.html":{"url":"es2021/string-replaceall.html","title":"String.prototype.replaceAll","keywords":"","body":"String.prototype.replaceAll() 简介 在 ES2021 之前，要替换掉一个字符串中的所有指定字符，不得不使用正则表达式的 g 修饰符。 'aabbcc'.replace(/b/g, '_'); // 'aa__cc' ES2021 可以用 String.prototype.replaceAll()替换全部字符串而不需要使用正则。 'aabbcc'.replaceAll('b', '_'); // 'aa__cc' 语法 const newStr = str.replaceAll(regexp|substr, newSubstr|function) 参数 regexp(pattern) 具有 g 修饰符的正则表达式。如果没有 g 修饰符，将抛出错误。 TypeError: \"replaceAll must be called with a global RegExp\". substr 需要匹配的字符串。 newSubstr(replacement) regexp 或 substr 要替换的字符串。其中可以使用一些特殊字符串： $&：匹配的子字符串。$` ：匹配结果前面的文本。$'：匹配结果后面的文本。$n：匹配成功的第 n 组内容，n 是从 1 开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。$$：指代美元符号$。 function(replacement) replaceAll()的第二个参数也可以是一个函数，该函数的返回值将替换掉第一个参数 searchValue 匹配的文本。 该函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。 const str = '123abc456'; const regex = /(\\d+)([a-z]+)(\\d+)/g; function replacer(match, p1, p2, p3, offset, string) { return [p1, p2, p3].join(' - '); } str.replaceAll(regex, replacer); // 123 - abc - 456 返回值 它的用法与 replace()相同，返回一个新字符串，不会改变原字符串。 示例 非全局 regex 抛出 'aabbcc'.replaceAll(/b/, '.'); // TypeError: replaceAll must be called with a global RegExp 正确用法： 'aabbcc'.replaceAll(/b/g, '.'); // \"aa..cc\" Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2021/promise-any.html":{"url":"es2021/promise-any.html","title":"Promise.any","keywords":"","body":"Promise.any() 简介 ES2021 引入了 Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成 fulfilled 状态，就返回那个已经成功的 Promise，如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。这个方法和 Promise.all()是相反的。 这个方法用于返回第一个成功的 Promise 实例。只要有一个 promise 成功此方法就会终止，它不会等待其他的 promise 全部完成。 示例 First to fulfil const pErr = new Promise((resolve, reject) => { reject('总是失败'); }); const pSlow = new Promise((resolve, reject) => { setTimeout(resolve, 500, '最终完成'); }); const pFast = new Promise((resolve, reject) => { setTimeout(resolve, 100, '很快完成'); }); Promise.any([pErr, pSlow, pFast]).then((value) => { console.log(value); // pFast fulfils first }); // \"很快完成\" Rejections with AggregateError 如果没有 fulfilled (成功的) promise，Promise.any() 返回 AggregateError 错误。 const pErr = new Promise((resolve, reject) => { reject('总是失败'); }); Promise.any([pErr]).catch((err) => { console.log(err); }); // \"AggregateError: No Promise in Promise.any was resolved\" 总结 语法 描述 阶段 Promise.all 成功：返回结果数据\\n 失败：返回最先 reject 的值 ES2015 Promise.race 返回最先有结果的 Promise 实例，不管成功失败 ES2015 Promise.allSettled 只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。 ES2020 Promise.any 返回第一个成功的 Promise 实例。只要有一个 promise 成功此方法就会终止，它不会等待其他的 promise 全部完成。 ES2021 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2021/weakrefs.html":{"url":"es2021/weakrefs.html","title":"WeakRefs","keywords":"","body":"WeakRefs 简介 WeakRef 对象包含对对象的弱引用，这个弱引用被称为该 WeakRef 对象的 target 或者是 referent。对对象的弱引用是指当该对象应该被 GC 回收时不会阻止 GC 的回收行为。而与此相反的，一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，JavaScript 引擎 GC 才会销毁该对象并且回收该对象所占的内存空间。 语法 构造函数 WeakRef()用来创建一个 WeakRef 对象。 实例方法 WeakRef.prototype.deref()返回当前实例的 WeakRef 对象所绑定的 target 对象，如果该 target 对象已被 GC 回收则返回 undefined。 示例 这个例子演示了在一个 DOM 元素中启动一个计数器，当这个元素不存在时停止: class Counter { constructor(element) { // Remember a weak reference to the DOM element this.ref = new WeakRef(element); this.start(); } start() { if (this.timer) { return; } this.count = 0; const tick = () => { // Get the element from the weak reference, if it still exists const element = this.ref.deref(); if (element) { element.textContent = ++this.count; } else { // The element doesn't exist anymore console.log('The element is gone.'); this.stop(); this.ref = null; } }; tick(); this.timer = setInterval(tick, 1000); } stop() { if (this.timer) { clearInterval(this.timer); this.timer = 0; } } } const counter = new Counter(document.getElementById('counter')); counter.start(); setTimeout(() => { document.getElementById('counter').remove(); }, 5000); 为什么尽量避免使用 正确使用 WeakRef 对象需要仔细的考虑，最好尽量避免使用。避免依赖于规范没有保证的任何特定行为也是十分重要的。何时、如何以及是否发生垃圾回收取决于任何给定 JavaScript 引擎的实现。GC 在一个 JavaScript 引擎中的行为有可能在另一个 JavaScript 引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中 GC 的行为都有可能有较大的差距。GC 目前还是 JavaScript 引擎实现者不断改进和改进解决方案的一个难题。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2021/logical-assignment.html":{"url":"es2021/logical-assignment.html","title":"Logical Assignment Operators","keywords":"","body":"逻辑赋值运算符 简介 逻辑赋值运算符结合逻辑运算符和赋值运算符，它让代码变得简短、让变量和对象属性条件赋值变得简单。ES2021 将推出三个新的逻辑操作符，每一个操作符都有两个运算元。 语法 expr1 ||= expr2 expr1 &&= expr2 expr1 ??= expr2 a ||= b; // 等效于以下两种写法 // a || (a = b); a为falsy时执行右边 // if(!a) a = b; a &&= b; // 等效于以下两种写法 // a && (a = b); a为truth时执行右边 // if(a) a = b a ??= b; // 等效于以下两种写法 // a ?? (a = b); a为undefined或null时执行右边 // if(a === nudefined || a === null) a = b; 示例 let obj = {}; obj.x ??= 0; console.log(obj.x); // 0 obj.x ||= 1; console.log(obj.x); // 1 obj.x &&= 2; console.log(obj.x); // 2 注意事项 a = a || b; // 与 a ||= b 不等价 a = a && b; // 与 a &&= b 不等价 a = a ?? b; // 与 a ??= b 不等价 不等价的原因在于，无论上面的每个逻辑表达式结果如何，都会进行赋值运算；而逻辑赋值运算符只会在条件成立的情况下进行赋值 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2021/numeric-separator.html":{"url":"es2021/numeric-separator.html","title":"Numeric Separators","keywords":"","body":"数值分隔符 简介 使用 _ 对数字进行分割，提高数字的可读性，例如在日常生活中数字通常是每三位数字之间会用 , 分割，以方便人快速识别数字。 示例 // 1000000000 不易辨识 const count1 = 1000000000; // 1_000_000_000 很直观 const count2 = 1_000_000_000; console.log(count1 === count2); // true Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/es2020.html":{"url":"es2020/es2020.html","title":"ECMAScript 2020 (ES11)","keywords":"","body":"ECMAScript 2020 (ES11) 目录 String.prototype.matchAll Dynamic Import BigInt Promise.allSettled globalThis for-in mechanics Optional Chaining Nullish coalescing Operator import.meta Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/string-matchall.html":{"url":"es2020/string-matchall.html","title":"String.prototype.matchAll","keywords":"","body":"String.prototype.matchAll 简介 ES2020 增加了 String.prototype.matchAll() 方法，可以一次性取出所有匹配。该方法返回遍历器，相对于数组，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 语法 str.matchAll(regexp) 参数 regexp：正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp。RegExp 必须是设置了全局模式 g 的形式，否则会抛出异常 TypeError。 返回值 一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。 实例 Regexp.exec() 和 matchAll() 在 matchAll 出现之前，通过在循环中调用 regexp.exec() 来获取所有匹配项信息（regexp 需使用 /g 标志） const regexp = RegExp('foo[a-z]*', 'g') const str = 'table football, foosball' let match while ((match = regexp.exec(str)) !== null) { console.log(`Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.`) } // expected output: \"Found football start=6 end=14.\" // expected output: \"Found foosball start=16 end=24.\" 使用 matchAll 会得到一个迭代器的返回值，配合 for...of, array spread, 或者 Array.from() 可以更方便实现功能 const regexp = RegExp('foo[a-z]*', 'g') const str = 'table football, foosball' const matches = str.matchAll(regexp) Array.from(str.matchAll(regexp), (m) => m[0]) // Array [ \"football\", \"foosball\" ] 如果没有 /g 标志，matchAll 会抛出异常。 const regexp = RegExp('[a-c]', '') const str = 'abc' Array.from(str.matchAll(regexp), (m) => m[0]) // TypeError: String.prototype.matchAll called with a non-global RegExp argument matchAll 相比 match 可以获取捕获组 当使用 match() 和 /g 标志方式获取匹配信息时，捕获组会被忽略 var regexp = /t(e)(st(\\d?))/g var str = 'test1test2' str.match(regexp) // Array ['test1', 'test2'] 使用 matchAll 可以通过如下方式获取分组捕获 let array = [...str.matchAll(regexp)] array[0] // ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4] array[1] // ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4] Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/dynamic-import.html":{"url":"es2020/dynamic-import.html","title":"Dynamic Import","keywords":"","body":"import() 函数 简介 import 命令被 JavaScript 引擎静态分析，先于模块内的其他语句执行，无法取代 require() 的动态加载功能，提案建议引入与 require 方法类似的 import 方法。 语法 import(specifier) 上面代码中，import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import() 函数就能接受什么参数，两者区别主要是后者为动态加载。 返回值 import() 返回一个 Promise 对象。来看一个官方例子。 Books Movies Video Games Content will load here! const main = document.querySelector('main') for (const link of document.querySelectorAll('nav > a')) { link.addEventListener('click', (e) => { e.preventDefault() import(`./section-modules/${link.dataset.entryModule}.js`) .then((module) => { module.loadPageInto(main) }) .catch((err) => { main.textContent = err.message }) }) } 上面的代码，import()函数是运行时执行，类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。 实例 按需加载 button.addEventListener('click', (event) => { import('./dialogBox.js') .then((dialogBox) => { dialogBox.open() }) .catch((error) => { /* Error handling */ }) }) 上面代码中，import()方法放在 click 事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。 条件加载 if (condition) { import('moduleA').then(...); } else { import('moduleB').then(...); } import()可以放在 if 代码块，根据不同的情况，加载不同的模块。 动态的模块路径 import(f()) .then(...); 上面代码中，根据函数 f 的返回结果，加载不同的模块。 在 async 函数中使用 async function main() { const myModule = await import('./myModule.js') const { export1, export2 } = await import('./myModule.js') const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]) } Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/bigint.html":{"url":"es2020/bigint.html","title":"BigInt","keywords":"","body":"BigInt 简介 JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了很大限制。一是数值的精度只能到 53 个二进制（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 Infinity。 ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 语法 定义一个 BigInt 可以用在一个整数字面量后面加 n 的方式定义一个 BigInt。 const a = 9007199254740991n 调用函数 BigInt()。 const b = BigInt(9007199254740991) 类型判断 使用 typeof 判断类型，BigInt 对象返回 \"bigint\" typeof 1n === 'bigint' // true typeof BigInt('1') === 'bigint' // true 使用 Object 包装后， BigInt 被认为是一个普通 \"object\" typeof Object(1n) === 'object' // true 类型转换 可以使用 Boolean()、Number()和 String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。 Boolean(0n) // false Boolean(1n) // true Number(1n) // 1 String(1n) // \"1\" 另外，取反运算符（!）也可以将 BigInt 转为布尔值。 !0n // true !1n // false 运算 以下操作符可以和 BigInt 一起使用： +、*、-、**、% 。除 >>>（无符号右移）之外的位操作也可以支持。因为 BigInt 都是有符号的， >>>（无符号右移）不能用于 BigInt。为了兼容 asm.js，BigInt 不支持单目 (+) 运算符。 除法运算 / 结果会向零取整，也就是说不会返回小数部分。 const expected = 4n / 2n // 2n const rounded = 5n / 2n // 2n, not 2.5n BigInt 不能与普通数值进行混合运算。 1n + 1.3 // 报错 上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如 (2n**53n + 1n) + 0.5 这个表达式，如果返回 BigInt 类型，0.5 这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。 同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。 // 错误的写法 Math.sqrt(4n) // 报错 // 正确的写法 Math.sqrt(Number(4n)) // 2 上面代码中，Math.sqrt 的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用 Number 方法转一下类型，才能进行计算。 比较 BigInt 和 Number 不是严格相等的，但是宽松相等的。 0n === 0 // false 0n == 0 // true 两者也可以混在一个数组内并排序。 const mixed = [4n, 6, -12n, 10, 4, 0, 0n] // [4n, 6, -12n, 10, 4, 0, 0n] mixed.sort() // [-12n, 0, 0n, 10, 4n, 4, 6] 条件 BigInt 转换成 Boolean 的时表现跟 Number 类似。 if (0n) { console.log('Hello from the if!') } else { console.log('Hello from the else!') } // \"Hello from the else!\" 0n || 12n // 12n 0n && 12n // 0n Boolean(0n) // false Boolean(12n) // true !12n // false !0n // true 静态方法 BigInt.asIntN() 将 BigInt 值转换为一个 -2width-1 与 2width-1-1 之间的有符号整数。 BigInt.asUintN() 将一个 BigInt 值转换为 0 与 2width-1 之间的无符号整数。 BigInt.parseInt() 近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。 实例方法 BigInt 对象继承了 Object 对象的两个实例方法。 BigInt.prototype.toString() BigInt.prototype.valueOf() 继承了 Number 对象的一个实例方法。 BigInt.prototype.toLocaleString() Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/promise-allSettled.html":{"url":"es2020/promise-allSettled.html","title":"Promise.allSettled","keywords":"","body":"Promise.allSettled 简介 如果等待多个 promise 返回结果，我们可以用 Promise.all([promise_1, promise_2])。但是该方法如果其中一个请求失败了，就会抛出错误。有时候我们希望某个请求失败后，其他请求的结果能够正常返回。针对这种情况 ES2020 引入了 Promise.allSettled() 方法 。 语法 Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。 const promise1 = Promise.resolve(3) const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo')) const promises = [promise1, promise2] Promise.allSettled(promises).then((results) => results.forEach((result) => console.log(result))) // Object { status: \"fulfilled\", value: 3 } // Object { status: \"rejected\", reason: \"foo\" } 该方法返回的新的 Promise 实例，一旦结束，状态总是 fulfilled，不会变成 rejected。状态变成 fulfilled 后，Promise 的监听函数接收到的参数是一个数组，该数组的每个成员都是一个对象，对应传入 Promise.allSettled()的两个 Promise 实例。每个对象都有 status 属性，该属性的值只可能是字符串 fulfilled 或字符串 rejected。fulfilled 时，对象有 value 属性，rejected 时有 reason 属性，对应两种状态的返回值。 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/global.html":{"url":"es2020/global.html","title":"globalThis","keywords":"","body":"globalThis 对象 简介 JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。 全局环境中，this 会返回顶层对象。但是，Node.js 模块中 this 返回的是当前模块，ES6 模块中 this 返回的是 undefined。 函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。虽然可以通过此方式获取全局对象，但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么 eval、new Function 这些方法都可能无法使用。 ES2020 引入了 globalThis 作为顶层对象。也就是说，在任何环境下，都可以通过 globalThis 来拿到顶层对象。 示例 在 globalThis 出现之前 var getGlobal = function () { if (typeof self !== 'undefined') { return self } if (typeof window !== 'undefined') { return window } if (typeof global !== 'undefined') { return global } throw new Error('unable to locate global object') } var globals = getGlobal() if (typeof globals.setTimeout !== 'function') { // 此环境中没有 setTimeout 方法！ } 有了 globalThis 之后 if (typeof globalThis.setTimeout !== 'function') { // 此环境中没有 setTimeout 方法！ } Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/for-in-order.html":{"url":"es2020/for-in-order.html","title":"for-in mechanics","keywords":"","body":"Specifying for-in enumeration order 简介 以前在不同的引擎下 for in 循环出来的内容顺序是可能不一样的，现在标准化了。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/optional-chaining.html":{"url":"es2020/optional-chaining.html","title":"Optional Chaining","keywords":"","body":"Optional Chaining 可选链操作符 简介 在编程中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取 message.body.user.firstName，安全的写法是写成下面这样。 const firstName = (message && message.body && message.body.user && message.body.user.firstName) || 'default' 上面例子中，firstName 属性在对象的第四层，所以需要判断四次，每一层是否有值。 这样的层层判断非常麻烦，因此 ES2020 引入了“可选链操作符”（optional chaining operator）?.，简化上面的写法。 const firstName = message?.body?.user?.firstName || 'default' 语法 obj?.prop // 对象属性obj?.[expr] // 对象属性arr?.[index] // 数组取值func?.(args) // 函数或对象方法的调用 基本使用 let myMap = new Map() myMap.set('foo', { name: 'baz', desc: 'inga' }) myMap.get('bar')?.name // undefined 表达式 let nestedProp = obj?.['prop' + 'Name'] 函数调用 let result = someInterface.customMethod?.() 访问数组 let arrayItem = arr?.[42] 短路计算 当在表达式中使用可选链时，如果左操作数是 null 或 undefined，表达式将不会被计算，例如： let potentiallyNullObj = null let x = 0 let prop = potentiallyNullObj?.[x++] console.log(x) // x 将不会被递增，依旧输出 0 delete 运算符 delete a?.b // 等同于 a == null ? undefined : delete a.b 上面代码中，如果 a 是 undefined 或 null，会直接返回 undefined，而不会进行 delete 运算。 使用空值合并操作符 空值合并操作符可以在使用可选链时设置一个默认值： let customer = { name: 'Carl', details: { age: 82 }, } let customerCity = customer?.city ?? '木子朗' console.log(customerCity) // \"木子朗\" 括号的影响 如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。 ;(a?.b).c( // 等价于 a == null ? undefined : a.b, ).c 上面代码中，?.对圆括号外部没有影响，不管 a 对象是否存在，圆括号后面的.c 总是会执行。 一般来说，使用?.运算符的场合，不应该使用圆括号。 不能用于赋值 let object = {} object?.property = 1 // Uncaught SyntaxError: Invalid left-hand side in assignment 右侧不得为十进制数值 为了保证兼容以前的代码，允许 foo?.3:0 被解析成 foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/nullish-coalescing.html":{"url":"es2020/nullish-coalescing.html","title":"Nullish coalescing Operator","keywords":"","body":"空值合并操作符 简介 当读取对象属性的时候，如果某个属性的值是 null 或 undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。 const text = settings.headerText || 'Hello, world!' 开发者的目的是，属性的值为 null 或 undefined，默认值生效，但是属性的值如果为空字符串或 false 或 0，默认值也会生效。 为了避免这种情况，ES2020 引入了空值合并操作符??。空值合并操作符是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。 语法 使用空值合并操作符 在这个例子中，使用空值合并操作符为常量提供默认值，保证常量不为 null 或者 undefined。 const nullValue = null const emptyText = '' // 空字符串，是一个假值，Boolean(\"\") === false const someNumber = 42 const valA = nullValue ?? 'valA 的默认值' const valB = emptyText ?? 'valB 的默认值' const valC = someNumber ?? 0 console.log(valA) // \"valA 的默认值\" console.log(valB) // \"\"（空字符串虽然是假值，但不是 null 或者 undefined） console.log(valC) // 42 短路 与 OR 和 AND 逻辑操作符相似，当左表达式不为 null 或 undefined 时，不会对右表达式进行求值。 function foo() { console.log('函数 foo 被调用了') } console.log(undefined ?? foo()) // \"函数 foo 被调用了\" console.log(false ?? foo()) // 右侧表达式没有被执行 与 AND 或 OR 操作符共用，需要带 () // 报错 lhs && middle ?? rhs lhs ?? middle && rhs lhs || middle ?? rhs lhs ?? middle || rhs 加入括号表示优先级 ;(lhs && middle) ?? rhs lhs && (middle ?? rhs)(lhs ?? middle) && rhs lhs ?? (middle && rhs)(lhs || middle) ?? rhs lhs || (middle ?? rhs)(lhs ?? middle) || rhs lhs ?? (middle || rhs) Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2020/import-meta.html":{"url":"es2020/import-meta.html","title":"import.meta","keywords":"","body":"import.meta 简介 开发者使用一个模块时，有时需要知道模板本身的一些信息（比如模块的路径）。ES2020 为 import 命令添加了一个元属性 import.meta，返回当前模块的元信息。 语法 import.meta 只能在模块内部使用，如果在模块外部使用会报错。 这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，import.meta 至少会有下面两个属性。 import.meta.url import.meta.url 返回当前模块的 URL 路径。举例来说，当前模块主文件的路径是 https://foo.com/main.js，import.meta.url 就返回这个路径。如果模块里面还有一个数据文件 data.txt，那么就可以用下面的代码，获取这个数据文件的路径。 new URL('data.txt', import.meta.url) 注意，Node.js 环境中，import.meta.url 返回的总是本地路径，即是 file:URL 协议的字符串，比如 file:///home/user/foo.js。 import.meta.scriptElement import.meta.scriptElement 是浏览器特有的元属性，返回加载模块的那个元素，相当于 document.currentScript 属性。 // HTML 代码为 // // my-module.js 内部执行下面的代码 import.meta.scriptElement.dataset.foo // \"abc\" Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/es2019.html":{"url":"es2019/es2019.html","title":"ECMAScript 2019 (ES10)","keywords":"","body":"ECMAScript 2019 (ES10) 目录 Optional catch binding JSON superset Symbol.prototype.description Function.prototype.toString Object.fromEntries Well-formed JSON.stringify String.prototype.{trimStart,trimEnd} Array.prototype.{flat,flatMap} Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/optional-catch-binding.html":{"url":"es2019/optional-catch-binding.html","title":"Optional catch binding","keywords":"","body":"可选的 catch 参数 JavaScript 语言的 try...catch 结构，以前明确要求 catch 命令后面必须跟参数，接受 try 代码块抛出的错误对象。 try { // ... } catch (err) { // 处理错误 } 上面代码中，catch 命令后面带有参数 err。 很多时候，catch 代码块可能用不到这个参数。但是，为了保证语法正确必须写。ES2019 允许 catch 语句省略参数。 try { // ... } catch { // ... } Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/json-superset.html":{"url":"es2019/json-superset.html","title":"JSON superset","keywords":"","body":"JSON 超集 之前如果 JSON 字符串中包含有行分隔符(\\u2028) 和段落分隔符(\\u2029)，那么在解析过程中会报错。 JSON.parse('\"\\u2028\"') // SyntaxError 现在 ES2019 对它们提供了支持。 JSON.parse('\"\\u2028\"') // '' Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/symbol-description.html":{"url":"es2019/symbol-description.html","title":"Symbol.prototype.description","keywords":"","body":"Symbol.prototype.description 简介 ES2019 提供了一个实例属性 description，直接返回 Symbol 的描述。description 是一个只读属性。 语法 Symbol('myDescription').description;Symbol.iterator.description;Symbol.for('foo').description; 创建 Symbol 的时候，可以添加一个描述。 const sym = Symbol('foo') 上面代码中，sym 的描述就是字符串 foo。 示例： Symbol('desc').toString() // \"Symbol(desc)\" Symbol('desc').description // \"desc\" Symbol('').description // \"\" Symbol().description // undefined // well-known symbols Symbol.iterator.toString() // \"Symbol(Symbol.iterator)\" Symbol.iterator.description // \"Symbol.iterator\" // global symbols Symbol.for('foo').toString() // \"Symbol(foo)\" Symbol.for('foo').description // \"foo\" Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/function-prototype-toString-revision.html":{"url":"es2019/function-prototype-toString-revision.html","title":"Function.prototype.toString","keywords":"","body":"Function.prototype.toString ES2019 对函数实例的 toString()方法做出了修订。 toString() 方法返回当前函数源代码的字符串，以前会省略注释和空格。 function /* foo comment */ foo() {} foo.toString() // function foo() {} 修改后的 toString()方法，返回一模一样的原始代码。 function /* foo comment */ foo() {} foo.toString() // \"function /* foo comment */ foo () {}\" Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/object-from-entries.html":{"url":"es2019/object-from-entries.html","title":"Object.fromEntries","keywords":"","body":"Object.fromEntries() 简介 Object.fromEntries()方法把键值对列表转换为一个对象，是 Object.entries()的逆操作。 Object.fromEntries([ ['foo', 'bar'], ['baz', 42], ]) // { foo: \"bar\", baz: 42 } 语法 Object.fromEntries(iterable); iterable类似 Array、Map 或者其它实现了可迭代协议的可迭代对象。 示例 Map 转化为 Object const map = new Map([ ['foo', 'bar'], ['baz', 42], ]) const obj = Object.fromEntries(map) console.log(obj) // { foo: \"bar\", baz: 42 } Array 转化为 Object const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'], ] const obj = Object.fromEntries(arr) console.log(obj) // { 0: \"a\", 1: \"b\", 2: \"c\" } 对象转换 Object.fromEntries 是与 Object.entries()相反的方法，用数组处理函数可以像下面这样转换对象： const object1 = { a: 1, b: 2, c: 3 } const object2 = Object.fromEntries(Object.entries(object1).map(([key, val]) => [key, val * 2])) console.log(object2) // { a: 2, b: 4, c: 6 } 配合 URLSearchParams 对象，将查询字符串转为对象 Object.fromEntries(new URLSearchParams('foo=bar&baz=qux')) // { foo: \"bar\", baz: \"qux\" } Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/well-formed-stringify.html":{"url":"es2019/well-formed-stringify.html","title":"Well-formed JSON.stringify","keywords":"","body":"更友好的 JSON.stringify 更友好的 JSON.stringify，对于一些超出范围的 Unicode 字符串，为其输出转义序列，使其成为有效 Unicode。 // Before console.log(JSON.stringify('\\uD800')) // \"�\" // ES2019 console.log(JSON.stringify('\\uD800')) // \"\\ud800\" Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/string-left-right-trim.html":{"url":"es2019/string-left-right-trim.html","title":"String.prototype.{trimStart,trimEnd}","keywords":"","body":"String.prototype.trimStart / String.prototype.trimEnd ES2019 对字符串实例新增了 trimStart()和 trimEnd()这两个方法。它们的行为与 trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 const s = ' abc ' s.trim() // \"abc\" s.trimStart() // \"abc \" s.trimEnd() // \" abc\" 上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 为了与 String.prototype.padStart 等函数保持一致，标准方法名称为trimStart。 但是，出于 Web 兼容性原因，浏览器还部署了额外的两个方法，trimLeft()是 trimStart()的别名，trimRight()是 trimEnd()的别名。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2019/array-prototype-flatMap.html":{"url":"es2019/array-prototype-flatMap.html","title":"Array.prototype.{flat,flatMap}","keywords":"","body":"Array.prototype.flat / Array.prototype.flatMap flat()方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat()方法的参数写成一个整数，表示想要拉平的层数，默认为 1。 [1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]] [1, 2, [3, [4, 5]]].flat(2) // [1, 2, 3, 4, 5] 如果不管有多少层嵌套，都要转成一维数组，可以用 Infinity 关键字作为参数。 [1, [2, [3]]].flat(Infinity) // [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 [1, 2, , 4, 5].flat() // [1, 2, 4, 5] flatMap()方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法，即 depth 值为 1。该方法返回一个新数组，不改变原数组。 let new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // return element for new_array }[, thisArg]) currentValue当前正在数组中处理的元素 index 可选可选的。数组中正在处理的当前元素的索引。 array 可选可选的。被调用的 map 数组 thisArg 可选可选的。执行 callback 函数时 使用的 this 值。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/es2018.html":{"url":"es2018/es2018.html","title":"ECMAScript 2018 (ES9)","keywords":"","body":"ECMAScript 2018 (ES9) 目录 Template Literal Revision s/dotAll flag for regular expressions RegExp Named Capture Groups Object Rest/Spread Properties RegExp Lookbehind Assertions Unicode property escapes in regular expressions Promise.prototype.finally Async Iteration Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/template-literal-revision.html":{"url":"es2018/template-literal-revision.html","title":"Template Literal Revision","keywords":"","body":"非转义序列的模板字符串的修订 带标签的模版字符串应该允许嵌套其他语言（例如 DSLs、LaTeX）。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 function latex(strings) { // ... } let document = latex` \\newcommand{\\fun}{\\textbf{Fun!}} // 正常工作 \\newcommand{\\unicode}{\\textbf{Unicode!}} // 报错 \\newcommand{\\xerxes}{\\textbf{King!}} // 报错 Breve over the h goes \\u{h}ere // 报错 ` 上面代码中，变量 document 内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 模板字符串会将\\u00FF 和\\u{42}当作 Unicode 字符进行转义，所以\\unicode 解析时报错；而\\x56 会被当作十六进制字符串转义，所以\\xerxes 会报错。也就是说，\\u 和\\x 在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 undefined，而不是报错，并且从 raw 属性上面可以得到原始字符串。 function tag(strs) { strs[0] === undefined strs.raw[0] === '\\\\unicode and \\\\u{55}' } tag`\\unicode and \\u{55}` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为 undefined，但是 raw 属性依然可以得到原始字符串，因此 tag 函数还是可以对原字符串进行处理。 注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。 let bad = `bad escape sequence: \\unicode` // 报错 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/regexp-dotall-flag.html":{"url":"es2018/regexp-dotall-flag.html","title":"s/dotAll flag for regular expressions","keywords":"","body":"正则表达式 dotAll 模式 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 u 修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） ;/foo.bar/.test('foo\\nbar') // false 上面代码中，因为.不匹配\\n，所以正则表达式返回 false。 S2018 引入 s 修饰符，使得.可以匹配任意单个字符。 ;/foo.bar/s.test('foo\\nbar') // true 这被称为 dotAll 模式，即点（dot）代表一切字符。 dotAll 是一个只读的属性，属于单个正则表达式实例。如果使用了 s 修饰符，dotAll 的值将返回 Boolean 类型的 true，否则将返回 false。 const re = /foo.bar/s // 另一种写法 // const re = new RegExp('foo.bar', 's'); re.test('foo\\nbar') // true re.dotAll // true re.flags // 's' /s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/regexp-named-groups.html":{"url":"es2018/regexp-named-groups.html","title":"RegExp Named Capture Groups","keywords":"","body":"正则表达式具名捕获组 正则表达式使用()进行组匹配。 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/ const matchObj = RE_DATE.exec('1999-12-31') const year = matchObj[1] // 1999 const month = matchObj[2] // 12 const day = matchObj[3] // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用索引取值，如果组的顺序变了，引用也需要修改。 ES2018 引入了具名捕获组（Named Capture Groups），允许为每一个组匹配指定一个名字。使用方式为 (?x)，尖括号( 和 >) 用于组名， 为指定的属性名，“x”是要匹配的字符串。 let users = `姓氏: 李, 名字: 雷 姓氏: 韩, 名字: 梅梅` let regexpNames = /姓氏: (?.+), 名字: (?.+)/gm let match = regexpNames.exec(users) do { console.log(`Hello ${match.groups.first} ${match.groups.last}`) } while ((match = regexpNames.exec(users)) !== null) // Hello 李 雷 // Hello 韩 梅梅 如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。 const RE_OPT_A = /^(?a+)?$/ const matchObj = RE_OPT_A.exec('') matchObj.groups.as // undefined matchObj.groups // {as: undefined} 'as' in matchObj.groups // true Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/object-rest-spread.html":{"url":"es2018/object-rest-spread.html","title":"Object Rest/Spread Properties","keywords":"","body":"对象的结构赋值和拓展运算符 ES2015 引入了 Rest 参数和扩展运算符（...）。但是 ES2015 中的作用对象仅限于数组。 restParam(1, 2, 3, 4, 5) function restParam(p1, p2, ...p3) { // p1 = 1 // p2 = 2 // p3 = [3, 4, 5] } const values = [99, 100, -1, 48, 16] console.log(Math.max(...values)) // 100 ES2018 为对象解构提供了和数组一样的 Rest 参数和展开操作符。 const myObject = { a: 1, b: 2, c: 3, } const { a, ...x } = myObject // a = 1 // x = { b: 2, c: 3 } function foo({ a, ...param }) { console.log(a) // 1 console.log(param) // {b: 2, c: 3} } 由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null，就会报错，因为它们无法转为对象。 let { ...z } = null // 运行时错误 let { ...z } = undefined // 运行时错误 解构赋值必须是最后一个参数，否则会报错。 let { ...x, y, z } = someObject; // 句法错误 let { x, ...y, ...z } = someObject; // 句法错误 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 let obj = { a: { b: 1 } } let { ...x } = obj obj.a.b = 2 x.a.b // 2 上面代码中，x 是解构赋值所在的对象，拷贝了对象 obj 的 a 属性。a 属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 let foo = { ...['a', 'b', 'c'] } foo // {0: \"a\", 1: \"b\", 2: \"c\"} 如果扩展运算符后面不是对象，则会自动将其转为对象。 // 等同于 {...Object(1)} {...1} // {} // 等同于 {...Object(true)} {...true} // {} // 等同于 {...Object(undefined)} {...undefined} // {} // 等同于 {...Object(null)} {...null} // {} 对象的扩展运算符等同于使用 Object.assign()方法。 let aClone = { ...a } // 等同于 let aClone = Object.assign({}, a) 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。 const obj = { ...(x > 1 ? { a: 1 } : {}), b: 2, } 扩展运算符的参数对象之中，如果有取值函数 get，这个函数是会执行的。 let a = { get x() { throw new Error('not throw yet') }, } let aWithXGetter = { ...a } // 报错 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/regexp-lookbehind.html":{"url":"es2018/regexp-lookbehind.html","title":"RegExp Lookbehind Assertions","keywords":"","body":"正则表达式的后行断言 JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言。 “先行断言”指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。 “先行否定断言”指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。 /\\d+(?=%)/.exec('100% of US presidents have been male') // [\"100\"] /\\d+(?!%)/.exec('that’s all 44 of them') // [\"44\"] “后行断言”正好与“先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?。比如，只匹配美元符号之后的数字，要写成/(?。 “后行否定断言”则与“先行否定断言”相反，x 只有不在 y 后面才匹配，必须写成/(?。比如，只匹配不在美元符号后面的数字，要写成/(?。 /(? “后行断言”的实现，需要先匹配/(?的 x，然后再回到左边，匹配 y 的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。 首先，后行断言的组匹配，与正常情况下结果是不一样的。 /(? 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。 其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 /(? 上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/regexp-unicode-property-escapes.html":{"url":"es2018/regexp-unicode-property-escapes.html","title":"Unicode property escapes in regular expressions","keywords":"","body":"正则表达式 Unicode 转义 在正则表达式中，我们通常使用 \\d 匹配任何数字，\\s 匹配任何不为空格的字符。 在 ES2018 添加了 Unicode 属性转义，用 \\p{} 匹配所有 Unicode 字符，否定为 \\P{}。 /^\\p{ASCII_Hex_Digit}+$/u.test('0123456789ABCDEF') // true /^\\p{ASCII_Hex_Digit}+$/u.test('h') // false 上面代码中，ASCII_Hex_Digit 是一个布尔属性，用于检查字符串是否仅包含有效的十六进制数字。 还有许多其他布尔属性，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji 等。 /^\\p{Lowercase}$/u.test('h') // true /^\\p{Uppercase}$/u.test('H') // true /^\\p{Emoji}+$/u.test('H') // false /^\\p{Emoji}+$/u.test('🙃🙃') // true 除了这些二进制属性之外，还可以检查任何 Unicode 字符属性以匹配特定值。 /^\\p{Script=Greek}+$/u.test('ελληνικ?') // true /^\\p{Script=Latin}+$/u.test('hey') // true 在这个例子中，检查字符串是用希腊语还是拉丁字母写的。 更多属性支持在这里查看 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/promise-finally.html":{"url":"es2018/promise-finally.html","title":"Promise.prototype.finally","keywords":"","body":"Promise.prototype.finally finally() 方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。 promise .then(result => {···}) .catch(error => {···}) .finally(() => {···}); 比如，服务器使用 Promise 处理请求，然后使用 finally 方法关掉服务器。 server .listen(port) .then(function () { // ... }) .finally(server.stop) 还有前端 loading 的场景控制。 let isLoading = true fetch(myRequest) .then(function (response) { var contentType = response.headers.get('content-type') if (contentType && contentType.includes('application/json')) { return response.json() } throw new TypeError(\"Oops, we haven't got JSON!\") }) .then(function (json) { /* process your JSON further */ }) .catch(function (error) { console.log(error) }) .finally(function () { isLoading = false }) Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2018/async-iteration.html":{"url":"es2018/async-iteration.html","title":"Async Iteration","keywords":"","body":"异步迭代器 for await...of 在 async/await 的某些时刻，你可能尝试在同步循环中调用异步函数。例如： async function process(array) { for (let i of array) { await doSomething(i) } } ES2018 引入异步迭代器（asynchronous iterators），await 可以和 for...of 循环一起使用，以串行的方式运行异步操作。 async function process(array) { for await (let i of array) { doSomething(i) } } for await...of 循环也可以用于同步遍历器。 ;(async function () { for await (const x of ['a', 'b']) { console.log(x) } })() // a // b Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/es2017.html":{"url":"es2017/es2017.html","title":"ECMAScript 2017 (ES8)","keywords":"","body":"ECMAScript 2017 (ES8) 目录 Async / Await Shared Memory and Atomics Object.values / Object.entries String padding Trailing comma Object.getOwnPropertyDescriptors Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/async-await.html":{"url":"es2017/async-await.html","title":"Async / Await","keywords":"","body":"Async / Await 简介 在 ES2015 中引入了 Promise 来解决“回调地域”的问题。时隔两年，ES2017 Async Functions 的出现，证明 Promise 不是最终的解决方案。 ES2017 标准引入了 Async Functions 的概念，使得异步操作变得更加方便。Async Functions 是 Generator 函数的语法糖，直观上看，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。 async 和 await，比起星号和 yield，语义更加清晰，更符合语义。并且 async 函数自带执行器，不需要像 Generator 函数一样，需要调用 next 方法，或者用 co 模块。async 函数的返回值是 Promise 对象，其内部可以看做是多个异步操作，包装成的一个 Promise 对象，而 await 命令是内部 then 命令的语法糖。 语法 返回 Promise 对象 async 函数返回一个 Promise 对象，如果代码中返回的是非 Promise 对象，JavaScript 会自动将其包装成 Promise.resolved() 的值。 async function test() { return 'hello world' } test().then((v) => console.log(v)) // \"hello world\" 也可以显示的返回一个 Promise，结果与上面例子相同。 async function test() { return Promise.resolve('hello world') } test().then((v) => console.log(v)) // \"hello world\" 如果 async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误会被 catch 方法捕获到。 async function test() { throw new Error('出错了') } test().then( (v) => console.log('resolve', v), (e) => console.log('reject', e), ) //reject Error: 出错了 await 命令 await 命令只能在 async 函数内部使用。 一般情况下， await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是，就直接返回对应的值。 async function test() { return await 'hello world' // 等同于 // return 'hello world' } test().then((v) => console.log(v)) // \"hello world\" 另一种情况是， await 接收一个 thenable 对象（具有可调用 then 方法的对象），那么 await 会将其等同于 Promise 对象。 class Thenable { constructor(num) { this.num = num } then(resolve, reject) { setTimeout(() => resolve(this.num * 2), 1000) } } ;(async () => { const result = await new Thenable(2) console.log(result) })() // 4 上面例子中， await 得到了一个带有 then 方法的非 Promise 对象，它会调用提供原生函数的 resolve、reject 作为参数的方法。 错误处理 如果一个 Promise 正常 resolve，那么 await 会返回这个结果，但是在 reject 的情况下会抛出一个错误。 async function test() { await Promise.reject(new Error('出错了！')) } test() .then((v) => console.log(v)) .catch((e) => console.log(e)) // Error：出错了 注意，和下面写法效果一样。 async function test() { throw new Error('出错了！') } 任何一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。 async function test() { await Promise.reject(new Error('出错了')) await Promise.resolve('hello world') // 不会执行 } 有时，我们希望即使一个异步操作失败，也不会中断后面的异步操作。可以将前面的 await 放在 try...catch 语句中。 async function test() { try { await Promise.reject(new Error('出错了')) } catch (e) { console.error(e) // Error: 出错了 } return await Promise.resolve('hello world') } test().then((v) => console.log(v)) // hello world 如果发生了错误，会被 catch 捕获到。当然如果有多个 await 命令，可以统一放在 try...catch 语句中处理。 Promise 对象的状态变化 使用注意点 实例 按顺序完成异步操作 实际开发中，经常遇到一组异步操作，如一组网络请求，需要按顺序完成，然后按照顺序输出结果。 Promise 写法如下。 function logInOrder(urls) { // 远程读取所有URL const textPromises = urls.map((url) => { return fetch(url).then((response) => response.text()) }) // 按次序输出 textPromises.reduce((chain, textPromise) => { return chain.then(() => textPromise).then((text) => console.log(text)) }, Promise.resolve()) } 上面代码使用 fetch 方法，请求一组 URL。每个 fetch 都会返回一个 Promise 对象，放入 textPromises 数组。然后，使用 reduce 方法依次处理每个 Promise 对象，然后使用 then 将所有 Promise 对象连接起来，依次输出结果。 下面用 async 函数改造。 async function logInOrder(urls) { for (const url of urls) { const response = await fetch(url) console.log(await response.text()) } } 上面代码简洁了很多，问题是所有 fetch 操作都是继发，效率很差。并发改造如下。 async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async (url) => { const response = await fetch(url) return response.text() }) // 按次序输出 for (const textPromise of textPromises) { console.log(await textPromise) } } 上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响。后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。 休眠效果 JavaScript 一直没有休眠的语法，但是借助 await 命令可以让程序停顿指定的时间。 function sleep(interval) { return new Promise((resolve) => { setTimeout(resolve, interval) }) } // 用法 async function log() { for (let i = 1; i 使用 try...catch 结构，实现多次重复尝试 在实际开发中，有时当由于网络等原因导致请求报错，我们期望请求能够重试指定的次数。 const NUM_RETRIES = 3 async function test() { let i for (i = 0; i Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/sharedmem.html":{"url":"es2017/sharedmem.html","title":"Shared Memory and Atomics","keywords":"","body":"Shared Memory and Atomics 简介 ECMAScript 2017 引入了一个新的构造函数 SharedArrayBuffer 和 具有辅助函数的命名空间对象 Atomics。 语法 SharedArrayBuffer JavaScript 是单线程，Web worker 引入了多线程：主线程用来与用户互动，Worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过 postMessage() 通信。 // 主线程 const w = new Worker('worker.js') w.postMessage('hello') w.onmessage = function (ev) { console.log(ev.data) } // worker.js onmessage = function (ev) { console.log(ev.data) postMessage('hi') } 上面代码中，主线程创建了一个 Woker 线程，该线程与主线程之间通过 postMessage() 通信。 线程之间的数据交换可以是各种格式，这种数据交换采用复制机制，即一个进程将要分享的数据复制一份，通过 postMessage 方法发送给另一个进程。如果数据量较大，通信的效率会明显较低。共享内存的方式，会大大提高效率。 SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，唯一的区别是后者无法共享数据。 new SharedArrayBuffer(length) 参数 length：所创建的数组缓冲区的大小，以字节(byte)为单位。 返回值 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 示例 // 主线程 // 新建 1KB 共享内存 const sharedBuffer = new SharedArrayBuffer(1024) // 主线程将共享内存的地址发送出去 w.postMessage(sharedBuffer) // 在共享内存上建立视图，供写入数据 const sharedArray = new Int32Array(sharedBuffer) // Worker 线程 onmessage = function (ev) { // 主线程共享的数据，就是 1KB 的共享内存 const sharedBuffer = ev.data // 在共享内存上建立视图，方便读写 const sharedArray = new Int32Array(sharedBuffer) // ... } 共享内存也可以在 Worker 线程创建，发给主线程。 注意： SharedArrayBuffer 与 ArrayBuffer 一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。 Atomics 多线程共享内存，最大的问题就是防止两个线程同时修改某个地址，或者说，当一个线程修改共享内存以后，必须有一个机制让其他线程同步。SharedArrayBuffer API 提供 Atomics 对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。 原子操作：多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。 与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。 方法 Atomics.store()，Atomics.load() store() 方法用来向共享内存写入数据，并返回该值。 load() 方法用来从共享内存读出数据。 Atomics.store(typedArray, index, value)Atomics.load(typedArray, index) typedArray 一个指定类型的 shared 数组. 类型为 Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, 或者 Uint32Array 其中一个。 index typedArray 中用来存储 value 的位置。 value 要存储的数字。 var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.store(ta, 0, 12) // 12 Atomics.load(ta, 0) // 12 Atomics.exchange() 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 Atomics.exchange(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.exchange(ta, 0, 12) // returns 0, the old value Atomics.load(ta, 0) // 12 Atomics.wait()，Atomics.notify() 这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。 Atomics.wait(typedArray, index, value[, timeout]) typedArray 一个共享的 Int32Array。 index typedArray 中要唤醒的目标索引。 value 给定需要检测的位置索引的预期值。 timeout 可选，超时前等待的毫秒数。 Infinity, 如未提供该参数，将为无穷大。 Atomics.notify(typedArray, index, count) count 要通知的正在休眠的代理的数量。默认是 +Infinity。 返回值 一个 String 字符串，值为 \"ok\", \"not-equal\", 或 \"timed-out\" 三种之一。 如果 sharedArray[index] 不等于 value，就返回字符串 not-equal，否则就进入休眠。如果 Atomics.notify() 方法唤醒，就返回字符串 ok；如果因为超时唤醒，就返回字符串 timed-out。 // Worker 线程 self.addEventListener( 'message', (event) => { const sharedArray = new Int32Array(event.data) const arrayIndex = 0 const expectedStoredValue = 50 Atomics.wait(sharedArray, arrayIndex, expectedStoredValue) console.log(Atomics.load(sharedArray, arrayIndex)) }, false, ) 上面代码中，Atomics.wait() 方法等同于告诉 Worker 线程，只要满足给定条件（sharedArray 的 0 号位置等于 50），就在这一行 Worker 线程进入休眠。 // 主线程 const newArrayValue = 100 Atomics.store(sharedArray, 0, newArrayValue) const arrayIndex = 0 const queuePos = 1 Atomics.notify(sharedArray, arrayIndex, queuePos) 上面代码中，sharedArray 的 0 号位置改为 100，然后就执行 Atomics.notify()方法，唤醒在 sharedArray 的 0 号位置休眠队列里的一个线程。 注意，浏览器的主线程不宜设置休眠，这会导致用户失去响应。而且，主线程实际上会拒绝进入休眠。 Atomics.add() 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。 Atomics.add(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.add(ta, 0, 12) // returns 0, the old value Atomics.load(ta, 0) // 12 Atomics.and() 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 Atomics.and(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 5 Atomics.and(ta, 0, 1) // returns 0, the old value Atomics.load(ta, 0) // 1 Atomics.compareExchange() 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 Atomics.compareExchange(typedArray, index, expectedValue, replacementValue) expectedValue 用于比较的值。 replacementValue 将要替换上的值。 var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 7 Atomics.compareExchange(ta, 0, 7, 12) // returns 7, the old value Atomics.load(ta, 0) // 12 Atomics.isLockFree() 返回一个布尔值，表示 Atomics 对象是否可以处理某个 size 的内存锁定。如果返回 false，应用程序就需要自己来实现锁定。 Atomics.isLockFree(size) Atomics.isLockFree(1) // true Atomics.isLockFree(2) // true Atomics.isLockFree(3) // false Atomics.isLockFree(4) // true Atomics.isLockFree(5) // false Atomics.isLockFree(6) // false Atomics.isLockFree(7) // false Atomics.isLockFree(8) // false Atomics.isLockFree(Float64Array.BYTES_PER_ELEMENT) // false,Atomics方法无法处理Float64Array Atomics.or() 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 Atomics.or(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 2 Atomics.or(ta, 0, 1) // returns 2, the old value Atomics.load(ta, 0) // 3 Atomics.sub() 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 Atomics.sub(typedArray, index, value) const sab = new SharedArrayBuffer(1024) const ta = new Uint8Array(sab) ta[0] = 48 Atomics.sub(ta, 0, 12) // returns 48, the old value Atomics.load(ta, 0) // 36 Atomics.xor() 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 Atomics.xor(typedArray, index, value) const sab = new SharedArrayBuffer(1024) const ta = new Uint8Array(sab) ta[0] = 5 Atomics.xor(ta, 0, 1) // returns 5, the old value Atomics.load(ta, 0) // 4 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/object-values-entries.html":{"url":"es2017/object-values-entries.html","title":"Object.values / Object.entries","keywords":"","body":"Object.values / Object.entries 简介 在 Object 中，ES2017 新增了两个新的函数，分别是 Object.values 函数和 Object.entries 函数。 Object.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）。 Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 两者枚举属性的顺序与通过手动循环对象的属性值所给出的顺序相同，如果属性名为数值的属性，是按照数值大小，从小到大遍历的。 语法 Object.values() 属性值为字符串 const obj = { foo: 'bar', baz: 'test' } Object.values(obj) // [\"bar\", \"test\"] 属性值为数字 const obj = { 666: 'a', 2: 'b', 8: 'c' } Object.values(obj) // [\"b\", \"c\", \"a\"] 上面例子中，属性名为数值，按照数值大小遍历，因此返回的顺序是 b、c、a。 只返回对象本身的可遍历属性 const obj = Object.create({}, { p: { value: 42 } }) Object.values(obj) // [] 上面代码中，Object.create 方法的第二个参数添加的对象属性 enumerable 默认是 false，Object.values 不会返回这个属性。只要把 enumerable 改成 true，Object.values 就会返回属性 p 的值。 const obj = Object.create( {}, { p: { value: 42, enumerable: true, }, }, ) Object.values(obj) // [42] 属性值为 Symbol Object.values({ [Symbol()]: 123, foo: 'abc' }) // ['abc'] Object.values 会过滤属性名为 Symbol 值的属性。 参数不是对象 如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.values('foo') // ['f', 'o', 'o'] 如果参数不是对象，Object.values 会先将其转为对象。 由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。 Object.values(42) // [] Object.values(true) // [] Object.entries() 除了返回值不一样，该方法的行为与 Object.values 基本一致。 遍历对象的属性 const obj = { a: 5, b: 7, c: 9 } for (const [key, value] of Object.entries(obj)) { console.log(`${key}: ${value}`) } // \"a: 5\", \"b: 7\", \"c: 9\" 将 Object 转为 Map 结构 new Map() 构造函数接受一个可迭代的 entries。借助 Object.entries 方法你可以很容易的将 Object 转换为 Map: var obj = { foo: 'bar', baz: 42 } var map = new Map(Object.entries(obj)) console.log(map) // Map { foo: \"bar\", baz: 42 } Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/string-pad-start-end.html":{"url":"es2017/string-pad-start-end.html","title":"String padding","keywords":"","body":"String padding 简介 在 String 对象中，ES2017 增加了两个新的函数，字符串补全长度功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart() 用于头部补全，padEnd() 用于尾部补全。 语法 str.padStart(targetLength [, padString])str.padEnd(targetLength [, padString]) 参数： targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString：可选，填充字符串。此参数的默认值为 \" \"。 返回值： 在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。 实例 原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/trailing-function-commas.html":{"url":"es2017/trailing-function-commas.html","title":"Trailing comma","keywords":"","body":"函数参数列表结尾允许逗号 简介 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 语法 function clownPuppiesEverywhere( param1, + param2 // this line ) { /* ... */ } clownPuppiesEverywhere( 'foo', + 'bar' // this line ) 上面代码中，如果修改代码添加第三个参数，或者调整参数的次序，就要在原来最后一个参数的后面添加逗号，对于版本管理来说，就会显示添加逗号的那一行发生了变动。看上去又写冗余。 function clownPuppiesEverywhere( param1, param2, // this line ) { /* ... */ } clownPuppiesEverywhere( 'foo', 'bar', // this line ) 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2017/object-getownpropertydescriptors.html":{"url":"es2017/object-getownpropertydescriptors.html","title":"Object.getOwnPropertyDescriptors","keywords":"","body":"Object.getOwnPropertyDescriptors 简介 ES5 的 Object.getOwnPropertyDescriptor() 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors() 方法，返回指定对象所有自身属性（非继承属性）的描述对象。 语法 基本用法如下。 const obj = { foo: 123, get bar() { return 'abc' }, } Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } 该方法的实现非常容易。 function getOwnPropertyDescriptors(obj) { const result = {} for (let key of Reflect.ownKeys(obj)) { result[key] = Object.getOwnPropertyDescriptor(obj, key) } return result } 该方法引入的目的，主要是为了解决 Object.assign() 无法正确拷贝 get 属性和 set 属性的问题。Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。 这时，Object.getOwnPropertyDescriptors() 方法配合 Object.defineProperties() 方法，就可以实现正确拷贝。 const source = { set foo(value) { console.log(value) }, } const target2 = {} Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) Object.getOwnPropertyDescriptor(target2, 'foo') // { get: undefined, // set: [Function: set foo], // enumerable: true, // configurable: true } 实例 浅拷贝一个对象 配合 Object.create() 方法，将对象属性克隆到一个新对象。 Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 创建子类 创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性。这么写很不优雅，特别是对于 getters 和 setter 而言。可以下面方式设置原型： function superclass() {} superclass.prototype = { // 在这里定义方法和属性 } function subclass() {} subclass.prototype = Object.create( superclass.prototype, Object.getOwnPropertyDescriptors({ // 在这里定义方法和属性 }), ) Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2016/es2016.html":{"url":"es2016/es2016.html","title":"ECMAScript 2016 (ES7)","keywords":"","body":"ECMAScript 2016 (ES7) 目录 Array.prototype.includes 求幂运算符(**) Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2016/array-prototype-includes.html":{"url":"es2016/array-prototype-includes.html","title":"Array.prototype.includes","keywords":"","body":"Array.prototype.includes() 简介 includes() 方法用来判断一个数组是否包含一个指定的值。如果包含则返回 true，否则返回 false。 语法 arr.includes(valueToFind[, fromIndex]) valueToFind 需要查找的元素值。 fromIndex 可选，从 fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。 示例 基本使用 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, 3].includes(3, 3) // false [1, 2, 3].includes(3, -1) // true [1, 2, NaN)].includes(NaN) // true fromIndex 大于等于数组长度 如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。 var arr = ['a', 'b', 'c'] arr.includes('c', 3) // false arr.includes('c', 100) // false 计算出的索引小于 0 如果 fromIndex 为负值，计算出的索引将作为开始搜索 searchElement 的位置。如果计算出的索引小于 0，则整个数组都会被搜索。 // array length is 3 // fromIndex is -100 // computed index is 3 + (-100) = -97 var arr = ['a', 'b', 'c'] arr.includes('a', -100) // true arr.includes('b', -100) // true arr.includes('c', -100) // true arr.includes('a', -2) // false Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "},"es2016/proposal-exponentiation-operator.html":{"url":"es2016/proposal-exponentiation-operator.html","title":"求幂运算符(**)","keywords":"","body":"求幂运算符(**) 语法 求幂运算符 ** 等价于 Math.pow()，但是它被引入语言本身，而不是库函数。 Math.pow(x, y) // 9 let squared = 3 ** 2 // 9 let num = 3 num **= 2 console.log(num) // 9 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2021-07-01 07:11:32 "}}